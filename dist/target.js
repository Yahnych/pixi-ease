const wait = require('./wait');

/** move an object to a target's location */
module.exports = class target extends wait {
    /**
     * move to a target
     * @param {object} object - object to animate
     * @param {object} target - object needs to contain {x: x, y: y}
     * @param {number} speed - number of pixels to move per millisecond
     * @param {object} [options] @see {@link Wait}
     * @param {boolean} [options.keepAlive] don't cancel the animation when target is reached
     */
    constructor(object, target, speed, options) {
        options = options || {};
        super(object, options);
        this.type = 'Target';
        this.target = target;
        if (options.load) {
            this.load(options.load);
        } else {
            this.speed = speed;
        }
    }

    save() {
        const save = super.save();
        save.speed = this.speed;
        save.keepAlive = this.options.keepAlive;
        return save;
    }

    load(load) {
        super.load(load);
        this.speed = load.speed;
        this.options.keepAlive = load.keepAlive;
    }

    calculate(elapsed) {
        const deltaX = this.target.x - this.object.x;
        const deltaY = this.target.y - this.object.y;
        if (deltaX === 0 && deltaY === 0) {
            this.emit('done', this.object);
            if (!this.options.keepAlive) {
                return true;
            }
        } else {
            const angle = Math.atan2(deltaY, deltaX);
            this.object.x += Math.cos(angle) * elapsed * this.speed;
            this.object.y += Math.sin(angle) * elapsed * this.speed;
            if (deltaX >= 0 !== this.target.x - this.object.x >= 0) {
                this.object.x = this.target.x;
            }
            if (deltaY >= 0 !== this.target.y - this.object.y >= 0) {
                this.object.y = this.target.y;
            }
        }
    }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90YXJnZXQuanMiXSwibmFtZXMiOlsid2FpdCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwidGFyZ2V0IiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJzcGVlZCIsIm9wdGlvbnMiLCJ0eXBlIiwibG9hZCIsInNhdmUiLCJrZWVwQWxpdmUiLCJjYWxjdWxhdGUiLCJlbGFwc2VkIiwiZGVsdGFYIiwieCIsImRlbHRhWSIsInkiLCJlbWl0IiwiYW5nbGUiLCJNYXRoIiwiYXRhbjIiLCJjb3MiLCJzaW4iXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLE9BQU9DLFFBQVEsUUFBUixDQUFiOztBQUVBO0FBQ0FDLE9BQU9DLE9BQVAsR0FBaUIsTUFBTUMsTUFBTixTQUFxQkosSUFBckIsQ0FDakI7QUFDSTs7Ozs7Ozs7QUFRQUssZ0JBQVlDLE1BQVosRUFBb0JGLE1BQXBCLEVBQTRCRyxLQUE1QixFQUFtQ0MsT0FBbkMsRUFDQTtBQUNJQSxrQkFBVUEsV0FBVyxFQUFyQjtBQUNBLGNBQU1GLE1BQU4sRUFBY0UsT0FBZDtBQUNBLGFBQUtDLElBQUwsR0FBWSxRQUFaO0FBQ0EsYUFBS0wsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsWUFBSUksUUFBUUUsSUFBWixFQUNBO0FBQ0ksaUJBQUtBLElBQUwsQ0FBVUYsUUFBUUUsSUFBbEI7QUFDSCxTQUhELE1BS0E7QUFDSSxpQkFBS0gsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDSjs7QUFFREksV0FDQTtBQUNJLGNBQU1BLE9BQU8sTUFBTUEsSUFBTixFQUFiO0FBQ0FBLGFBQUtKLEtBQUwsR0FBYSxLQUFLQSxLQUFsQjtBQUNBSSxhQUFLQyxTQUFMLEdBQWlCLEtBQUtKLE9BQUwsQ0FBYUksU0FBOUI7QUFDQSxlQUFPRCxJQUFQO0FBQ0g7O0FBRURELFNBQUtBLElBQUwsRUFDQTtBQUNJLGNBQU1BLElBQU4sQ0FBV0EsSUFBWDtBQUNBLGFBQUtILEtBQUwsR0FBYUcsS0FBS0gsS0FBbEI7QUFDQSxhQUFLQyxPQUFMLENBQWFJLFNBQWIsR0FBeUJGLEtBQUtFLFNBQTlCO0FBQ0g7O0FBRURDLGNBQVVDLE9BQVYsRUFDQTtBQUNJLGNBQU1DLFNBQVMsS0FBS1gsTUFBTCxDQUFZWSxDQUFaLEdBQWdCLEtBQUtWLE1BQUwsQ0FBWVUsQ0FBM0M7QUFDQSxjQUFNQyxTQUFTLEtBQUtiLE1BQUwsQ0FBWWMsQ0FBWixHQUFnQixLQUFLWixNQUFMLENBQVlZLENBQTNDO0FBQ0EsWUFBSUgsV0FBVyxDQUFYLElBQWdCRSxXQUFXLENBQS9CLEVBQ0E7QUFDSSxpQkFBS0UsSUFBTCxDQUFVLE1BQVYsRUFBa0IsS0FBS2IsTUFBdkI7QUFDQSxnQkFBSSxDQUFDLEtBQUtFLE9BQUwsQ0FBYUksU0FBbEIsRUFDQTtBQUNJLHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBUEQsTUFTQTtBQUNJLGtCQUFNUSxRQUFRQyxLQUFLQyxLQUFMLENBQVdMLE1BQVgsRUFBbUJGLE1BQW5CLENBQWQ7QUFDQSxpQkFBS1QsTUFBTCxDQUFZVSxDQUFaLElBQWlCSyxLQUFLRSxHQUFMLENBQVNILEtBQVQsSUFBa0JOLE9BQWxCLEdBQTRCLEtBQUtQLEtBQWxEO0FBQ0EsaUJBQUtELE1BQUwsQ0FBWVksQ0FBWixJQUFpQkcsS0FBS0csR0FBTCxDQUFTSixLQUFULElBQWtCTixPQUFsQixHQUE0QixLQUFLUCxLQUFsRDtBQUNBLGdCQUFLUSxVQUFVLENBQVgsS0FBb0IsS0FBS1gsTUFBTCxDQUFZWSxDQUFaLEdBQWdCLEtBQUtWLE1BQUwsQ0FBWVUsQ0FBN0IsSUFBbUMsQ0FBMUQsRUFDQTtBQUNJLHFCQUFLVixNQUFMLENBQVlVLENBQVosR0FBZ0IsS0FBS1osTUFBTCxDQUFZWSxDQUE1QjtBQUNIO0FBQ0QsZ0JBQUtDLFVBQVUsQ0FBWCxLQUFvQixLQUFLYixNQUFMLENBQVljLENBQVosR0FBZ0IsS0FBS1osTUFBTCxDQUFZWSxDQUE3QixJQUFtQyxDQUExRCxFQUNBO0FBQ0kscUJBQUtaLE1BQUwsQ0FBWVksQ0FBWixHQUFnQixLQUFLZCxNQUFMLENBQVljLENBQTVCO0FBQ0g7QUFDSjtBQUNKO0FBbEVMLENBREEiLCJmaWxlIjoidGFyZ2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgd2FpdCA9IHJlcXVpcmUoJy4vd2FpdCcpXG5cbi8qKiBtb3ZlIGFuIG9iamVjdCB0byBhIHRhcmdldCdzIGxvY2F0aW9uICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHRhcmdldCBleHRlbmRzIHdhaXRcbntcbiAgICAvKipcbiAgICAgKiBtb3ZlIHRvIGEgdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIG9iamVjdCB0byBhbmltYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCBuZWVkcyB0byBjb250YWluIHt4OiB4LCB5OiB5fVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCAtIG51bWJlciBvZiBwaXhlbHMgdG8gbW92ZSBwZXIgbWlsbGlzZWNvbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEBzZWUge0BsaW5rIFdhaXR9XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5rZWVwQWxpdmVdIGRvbid0IGNhbmNlbCB0aGUgYW5pbWF0aW9uIHdoZW4gdGFyZ2V0IGlzIHJlYWNoZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvYmplY3QsIHRhcmdldCwgc3BlZWQsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgICBzdXBlcihvYmplY3QsIG9wdGlvbnMpXG4gICAgICAgIHRoaXMudHlwZSA9ICdUYXJnZXQnXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAgIGlmIChvcHRpb25zLmxvYWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubG9hZChvcHRpb25zLmxvYWQpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNhdmUoKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc2F2ZSA9IHN1cGVyLnNhdmUoKVxuICAgICAgICBzYXZlLnNwZWVkID0gdGhpcy5zcGVlZFxuICAgICAgICBzYXZlLmtlZXBBbGl2ZSA9IHRoaXMub3B0aW9ucy5rZWVwQWxpdmVcbiAgICAgICAgcmV0dXJuIHNhdmVcbiAgICB9XG5cbiAgICBsb2FkKGxvYWQpXG4gICAge1xuICAgICAgICBzdXBlci5sb2FkKGxvYWQpXG4gICAgICAgIHRoaXMuc3BlZWQgPSBsb2FkLnNwZWVkXG4gICAgICAgIHRoaXMub3B0aW9ucy5rZWVwQWxpdmUgPSBsb2FkLmtlZXBBbGl2ZVxuICAgIH1cblxuICAgIGNhbGN1bGF0ZShlbGFwc2VkKVxuICAgIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gdGhpcy50YXJnZXQueCAtIHRoaXMub2JqZWN0LnhcbiAgICAgICAgY29uc3QgZGVsdGFZID0gdGhpcy50YXJnZXQueSAtIHRoaXMub2JqZWN0LnlcbiAgICAgICAgaWYgKGRlbHRhWCA9PT0gMCAmJiBkZWx0YVkgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZG9uZScsIHRoaXMub2JqZWN0KVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMua2VlcEFsaXZlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpXG4gICAgICAgICAgICB0aGlzLm9iamVjdC54ICs9IE1hdGguY29zKGFuZ2xlKSAqIGVsYXBzZWQgKiB0aGlzLnNwZWVkXG4gICAgICAgICAgICB0aGlzLm9iamVjdC55ICs9IE1hdGguc2luKGFuZ2xlKSAqIGVsYXBzZWQgKiB0aGlzLnNwZWVkXG4gICAgICAgICAgICBpZiAoKGRlbHRhWCA+PSAwKSAhPT0gKCh0aGlzLnRhcmdldC54IC0gdGhpcy5vYmplY3QueCkgPj0gMCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3QueCA9IHRoaXMudGFyZ2V0LnhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGVsdGFZID49IDApICE9PSAoKHRoaXMudGFyZ2V0LnkgLSB0aGlzLm9iamVjdC55KSA+PSAwKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdC55ID0gdGhpcy50YXJnZXQueVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSJdfQ==